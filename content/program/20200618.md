---
title: "[Three.js] Object & Texture Loading 的 Callback & Promise 問題"
date: 2020-06-18T11:40:11+08:00
publishdate: 2020-06-18T11:40:11+08:00
tags: ["computer graphics", "javascript"]
comments: false
---

Three.js是一個建構在WebGL的Graphics Library，可以快速地讓開發者在網頁上進行3D Render開發
<!--more-->

但是目前了解的Three.js THREE.OBJECTLOADER & THREE.TEXTURE裡面的方法都是用Callback的寫法，也是就會發生下列的狀況。
根據[THREE.JS OBJLoader Code Sample](https://threejs.org/docs/#examples/en/loaders/OBJLoader)

```
// instantiate a loader
var loader = new OBJLoader();

// load a resource
loader.load(
	// resource URL
	'models/monster.obj',
	// called when resource is loaded
	function ( object ) {

		scene.add( object );

	},
	// called when loading is in progresses
	function ( xhr ) {

		console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

	},
	// called when loading has errors
	function ( error ) {

		console.log( 'An error happened' );

	}
);
```

我們看了一下上面的Sample Code，就會發現object 在Callback裡面load完後才放進scene裡面。
這時候我們進一步進去看[OBJLoader.js的實作細節](https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/OBJLoader.js)

```
load: function ( url, onLoad, onProgress, onError ) {

        var scope = this;

        var loader = new FileLoader( scope.manager );
        loader.setPath( this.path );
        loader.load( url, function ( text ) {

            try {

                onLoad( scope.parse( text ) );

            } catch ( e ) {

                if ( onError ) {

                    onError( e );

                } else {

                    console.error( e );

                }

                scope.manager.itemError( url );

            }

        }, onProgress, onError );

    },
```

會發現主要流程是

1. var loader = new FileLoader( scope.manager );
2. loader.load( url, function ( text ) {...}
3. try catch裡面執行Callback  onLoad( scope.parse( text ) );

也就是說，會把.obj當作文字檔放入FileLoader裡面去讀文字檔，接著在Callback裡面放入parse()裡面再組成Object的結構。

這時候就會發生一個問題，當Object or Texture檔案太大，造成遠端網路連線發生傳輸過久等相關問題，也就是所有程式碼都跑完了，還在等Callback，再加上一次同步Load很多檔案，進行非同步處理，這時候就會發生問題了，可能會漏檔或是Object Load好但是Texture還在跑就先Render了，於是Render出黑黑沒有Texture的物件。

我們來看一下下面的例子
根據[Three.js ObjectLoader Sample](https://github.com/mrdoob/three.js/blob/master/examples/webgl_loader_obj.html) 

```
var textureLoader = new THREE.TextureLoader( manager );

var texture = textureLoader.load( 'textures/uv_grid_opengl.jpg', function ( tex ) { } );

// model
var loader = new OBJLoader( manager );

loader.load( 'models/obj/male02/male02.obj', function ( obj ) {

	object = obj;
	object.traverse( function ( child ) {
		if ( child.isMesh ) child.material.map = texture;
	} );
	scene.add( object );

}, onProgress, onError );
```

大概像這樣，TextureLoader有自己的Callback，Load完Texture，才有辦法在Callback做一些Texture Post-Processing動作。 而ObjectLoader也有自己的Callback，Load 完Object才有後續的處理動作。

在這種狀態下，如果想要結合JavaScript Promise相關操作，例如 

```
var loadTexture = function (...) {
	var textureLoader = new THREE.TextureLoader( manager );
	var texture = textureLoader.load( 'textures/uv_grid_opengl.jpg', function ( tex ) {
			......
			console.log("Finish Texture Loading");
		}
	);
	return Promise.resolve(...)
}

var loadObect = function (...) {
	var loader = new OBJLoader( manager );
	loader.load( 'models/obj/male02/male02.obj', function ( obj ) {
			......
			console.log("Finish Object Loading");
		}
	);
  return Promise.resolve(...)
}

var loadData = function () {
  loadPipeline
    .then(loadTexture)
    .then(loadObect)
    .then(
		console.log("post-processing")
		...
    })
}
```

原本以為應該要印出來像是

	Finish Texture Loading
	Finish Object Loading
	post-processing

但當Texture或Object檔案一大或網路太慢，就會變成

	post-processing
	Finish Texture Loading
	Finish Object Loading
	
完全跟想像不一樣啊

因為Promise在JavaScript上原本是用來解決Callback Hell的問題，結果把Callback放進Promise Function內使用，完全衝突!!

<br>
***

### 歸納心得整理

或許Three.js當作WebGL Viewer開發會非常快速，但是如果要建立一個穩定的3D Render Platform的話，那就必須認真考慮到Object & Texture File傳輸與管理的問題。

以下有一些可以參考的方向

<br>

#### Three.js本身提供的THREE.LoadingManager

其實這個Library套件本身就有提供THREE.LoadingManager進行偵測Loading相關進度，裡面有類似onProgress這樣的Callback function可以去放進 OBJLoader or TextureLoader中去追蹤loading進度，可以參考使用。

<br>

#### 自行管理好Callback使用

其實也可以自行管理好Callback的使用，這時候，可能在建立Mesh的Struture結構上，要花一點心思，尤其在檔案管理及記憶體管理還有Texture or Object抽換的動作上，要自行寫好註解或特別注意了。因為要盡可能避免Callback Hell的問題了(傳說中的Callback Hell會造成其他一起負責看Code人在Debug超痛苦阿~~)

<br>

#### 改寫Three.js成Promise結構

也可以改寫Three.js的Loader結構，把它從Callback結構改成Promise結構，之後整個流程追蹤會好很多。但這有一個很大的問題是，Three.js Repo是一個版號不停更新的Project，可能之後的程式更新和管理都要使用者自行負責了。
